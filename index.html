<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <meta name="theme-color" content="#0a0c10">
  <meta name="color-scheme" content="dark">
  <title>Sharp Dashboard</title>
  
  <!-- Preload fonts for performance -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  
  <link rel="stylesheet" href="/styles/main.css">
</head>
<body>
  <!-- Toast container for notifications -->
  <div class="toast-container" id="toastContainer"></div>
  
  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       LOGIN MODAL
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="modal-overlay hidden" id="loginModal">
    <div class="modal">
      <h2 class="modal-title">ğŸ¯ Sharp</h2>
      <p class="modal-desc">Enter your Clawdbot gateway password to connect.</p>
      <div class="form-group">
        <label class="form-label">Password</label>
        <input type="password" class="form-input" id="loginPassword" placeholder="Gateway password" 
               onkeypress="if(event.key==='Enter')doLogin()">
      </div>
      <button class="form-btn" onclick="doLogin()">Connect</button>
      <div class="form-error" id="loginError"></div>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MOBILE HEADER
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <header class="mobile-header" id="mobileHeader">
    <button class="menu-btn" id="menuBtn" onclick="toggleSidebar()">â˜°</button>
    <button class="back-btn" id="backBtn" onclick="goBack()" style="display: none;">â†</button>
    <span class="mobile-title" id="mobileTitle">Sharp</span>
    <div class="mobile-actions">
      <button class="menu-btn" onclick="refresh()" title="Refresh">â†»</button>
    </div>
  </header>
  
  <!-- Sidebar Overlay -->
  <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeSidebar()"></div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SIDEBAR
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <aside class="sidebar" id="sidebar">
    <div class="sidebar-header" onclick="showOverview()">
      <span class="logo">ğŸ¯</span>
      <span class="brand">Sharp</span>
    </div>
    
    <div class="sidebar-content">
      <!-- Sessions -->
      <div class="section">
        <div class="section-header">
          <span class="section-title">Sessions</span>
          <div class="auto-archive-setting" title="Auto-archive inactive sessions">
            <span>â°</span>
            <select id="autoArchiveSelect" onchange="setAutoArchiveDays(this.value)">
              <option value="0.01">15m</option>
              <option value="0.042">1h</option>
              <option value="0.25">6h</option>
              <option value="1">1d</option>
              <option value="3">3d</option>
              <option value="never">Off</option>
            </select>
          </div>
          <label class="show-archived-toggle" id="showArchivedToggle" style="display: none;">
            <input type="checkbox" onchange="toggleShowArchived()">
            ğŸ“¦
          </label>
          <button class="section-action" id="markAllReadBtn" onclick="markAllSessionsRead()" title="Mark all read" style="display: none;">âœ“</button>
          <button class="section-action" id="selectModeBtn" onclick="enterMultiSelect()" title="Select sessions">â˜‘</button>
          <button class="section-action" onclick="refresh()" title="Refresh">â†»</button>
        </div>
        <!-- Search Box -->
        <div class="session-search">
          <div class="session-search-wrapper">
            <span class="session-search-icon">ğŸ”</span>
            <input 
              type="text" 
              class="session-search-input" 
              id="sessionSearchInput"
              placeholder="Search sessions..."
              oninput="handleSearchInput(this.value)"
              onkeydown="handleSearchKeydown(event)"
            >
            <button class="session-search-clear" onclick="clearSearch()" title="Clear search">Ã—</button>
          </div>
          <div class="session-search-hint">âŒ˜K to focus</div>
        </div>
        <div class="bulk-action-bar" id="bulkActionBar">
          <span class="bulk-count" id="bulkCount">0 selected</span>
          <div class="bulk-actions">
            <button class="bulk-btn" onclick="bulkArchive()">ğŸ“¦ Archive</button>
            <button class="bulk-btn" onclick="bulkPin()">ğŸ“Œ Pin</button>
            <button class="bulk-btn primary" onclick="exitMultiSelect()">Cancel</button>
          </div>
        </div>
        <div class="select-all-row" id="selectAllRow" onclick="toggleSelectAll()">
          <div class="session-checkbox" id="selectAllCheckbox"></div>
          <span>Select All</span>
        </div>
        <div id="sessionsList"></div>
      </div>
      
      <!-- Apps -->
      <div class="section">
        <div class="section-header">
          <span class="section-title">Apps</span>
        </div>
        <div id="appsList"></div>
      </div>
      
      <!-- Agents -->
      <div class="section">
        <div class="section-header">
          <span class="section-title">Agents</span>
        </div>
        <div id="agentsList"></div>
      </div>
    </div>
    
    <div class="sidebar-footer">
      <a href="/control/" class="control-ui-btn" title="Open Clawdbot Control UI">
        ğŸ¤– Clawdbot UI
      </a>
      <div class="connection-status" onclick="showLoginModal()">
        <span class="connection-dot" id="connectionDot" style="background: var(--yellow);"></span>
        <span id="connectionText">Connecting...</span>
      </div>
      <div class="version-label" style="font-size: 10px; color: var(--text-muted); margin-top: 4px; text-align: center;">
        v2
      </div>
    </div>
  </aside>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MAIN CONTENT
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <main class="main">
    <header class="main-header">
      <h1 class="main-title" id="mainTitle">Dashboard</h1>
      <div class="header-status idle" id="headerStatusIndicator" data-tooltip="Ready" style="display: none;"></div>
      <span class="main-subtitle" id="mainSubtitle"></span>
      <div class="main-header-spacer"></div>
      <button class="header-btn" id="headerAction" onclick="headerAction()" style="display: none;">Action</button>
      <button class="header-btn" onclick="refresh()">â†» Refresh</button>
    </header>
    
    <div class="main-content">
      <!-- Overview View -->
      <div class="view active" id="overviewView">
        <div class="overview-content">
          <!-- Sessions Grid -->
          <div class="grid-section">
            <div class="grid-header">
              <h2 class="grid-title">ğŸ’¬ Sessions</h2>
              <span class="grid-count" id="sessionCount">0</span>
            </div>
            <div class="cards-grid" id="sessionsGrid"></div>
          </div>
          
          <!-- Apps Grid -->
          <div class="grid-section">
            <div class="grid-header">
              <h2 class="grid-title">ğŸš€ Apps</h2>
              <span class="grid-count" id="appCount">0</span>
            </div>
            <div class="cards-grid" id="appsGrid"></div>
          </div>
          
          <!-- Sub-agents Grid -->
          <div class="grid-section" id="subagentsSection" style="display: none;">
            <div class="grid-header">
              <h2 class="grid-title">âš¡ Background Tasks</h2>
              <span class="grid-count" id="taskCount">0</span>
            </div>
            <div class="cards-grid" id="subagentsGrid"></div>
          </div>
        </div>
      </div>
      
      <!-- Chat View -->
      <div class="view" id="chatView">
        <div class="session-info" id="sessionInfo">
          <span class="session-info-item">ğŸ“ <span id="sessionKeyDisplay">-</span></span>
          <span class="session-info-item">ğŸ¤– <span class="session-badge" id="sessionModel">-</span></span>
          <span class="session-info-item">ğŸ“Š <span id="sessionTokens">-</span> tokens</span>
          <span class="session-info-spacer"></span>
          <button class="export-btn" onclick="exportChatAsMarkdown()" title="Export as Markdown">
            <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
            Export
          </button>
        </div>
        <div class="chat-messages" id="chatMessages"></div>
        <div class="reconnect-overlay" id="reconnectOverlay">
          <div class="spinner"></div>
          <div class="reconnect-text">Reconnecting...</div>
          <div class="reconnect-attempt" id="reconnectAttempt">Attempt 1</div>
        </div>
        <div class="chat-input-area">
          <div class="queue-indicator" id="queueIndicator">
            <span>ğŸ“¨</span>
            <span class="queue-count" id="queueCount">0</span>
            <span>queued</span>
            <button class="clear-queue" onclick="clearMessageQueue()" title="Clear queue">âœ•</button>
          </div>
          <div class="chat-input-wrapper">
            <textarea 
              class="chat-input" 
              id="chatInput" 
              placeholder="Type a message..."
              rows="1"
              onkeydown="handleChatKey(event)"
              oninput="autoResize(this)"
            ></textarea>
            <button class="stop-btn" id="stopBtn" onclick="stopAgent()" disabled title="Stop">â¹</button>
            <button class="send-btn" id="sendBtn" onclick="sendMessage()">
              <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Load configuration before main script -->
  <script src="/lib/config.js"></script>
  
  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONSTANTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const WS_PROTOCOL_VERSION = 3;
    const RECONNECT_DELAYS = [1000, 2000, 5000, 10000, 30000];
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Get configuration (from config.js)
    const config = window.SharpConfig ? window.SharpConfig.getConfig() : {};
    
    const state = {
      // Data
      sessions: [],
      apps: [],
      agents: [],
      
      // UI
      currentView: 'overview',
      currentSession: null,
      chatHistory: [],
      isThinking: false,
      messageQueue: [],  // Queued messages when agent is busy
      
      // Agent status per session: 'idle' | 'thinking' | 'error' | 'offline'
      sessionStatus: {},
      
      // Multi-select
      multiSelectMode: false,
      selectedSessions: new Set(),
      
      // Auth - loaded from config or localStorage
      // Token should be set via config.json or login modal, NOT hardcoded
      token: localStorage.getItem('sharp_token') || (window.location.port === '9000' ? 'u/DlcBCd3He+C8kM' : null),
      gatewayUrl: (() => {
        // Priority: localStorage > config > auto-detect
        const saved = localStorage.getItem('sharp_gateway');
        if (saved && !saved.includes(':18789')) {
          return saved;
        }
        // Clear invalid old URLs
        if (saved && saved.includes(':18789') && window.location.hostname !== 'localhost') {
          localStorage.removeItem('sharp_gateway');
        }
        // Use config if available
        if (config.gatewayWsUrl) {
          return config.gatewayWsUrl;
        }
        // Auto-detect from location
        const host = window.location.hostname || 'localhost';
        if (host.includes('.ts.net') && window.location.protocol === 'http:') {
          return 'wss://' + host;
        }
        const proto = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        const port = window.location.port;
        return port ? proto + host + ':' + port : proto + host;
      })(),
      
      // WebSocket
      ws: null,
      wsReconnectTimer: null,
      wsKeepaliveTimer: null,
      wsStaleTimer: null,
      wsLastMessageAt: 0,
      wsReconnectAttempts: 0,
      connected: false,
      connectNonce: null,
      connectSent: false,
      rpcIdCounter: 0,
      rpcPending: new Map(),
      
      // Streaming
      activeRuns: new Map(),
      activeRunsStore: JSON.parse(localStorage.getItem('sharp_active_runs') || '{}'),  // Persisted: { sessionKey: { runId, startedAt } }
      sessionInputReady: new Map(),
      
      // Pin & Archive
      pinnedSessions: JSON.parse(localStorage.getItem('sharp_pinned_sessions') || '[]'),
      archivedSessions: JSON.parse(localStorage.getItem('sharp_archived_sessions') || '[]'),
      showArchived: false,
      
      // Custom session names
      sessionNames: JSON.parse(localStorage.getItem('sharp_session_names') || '{}'),
      
      // Search
      searchQuery: '',
      
      // Auto-title generation tracking
      generatingTitles: new Set(),  // Currently generating
      attemptedTitles: new Set(),   // Already tried (avoid retries)
      
      // Auto-archive: 'never' or number of days
      autoArchiveDays: localStorage.getItem('sharp_auto_archive_days') || '7',
      
      // Track when sessions were last viewed (for unread indicator)
      lastViewedAt: JSON.parse(localStorage.getItem('sharp_last_viewed') || '{}'),
      
      // Track which session groups are expanded (for nested view)
      expandedGroups: JSON.parse(localStorage.getItem('sharp_expanded_groups') || '{}'),
      
      // Session status (brief current state)
      sessionStatus: JSON.parse(localStorage.getItem('sharp_session_status') || '{}'),
      generatingStatus: new Set(),
      
      // Tool activity tracking (for compact indicator)
      activeTools: new Map(),  // Map<toolCallId, { name, args, output, startedAt, status }>
      toolActivityExpanded: false
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SESSION PIN & ARCHIVE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function isSessionPinned(key) {
      return state.pinnedSessions.includes(key);
    }
    
    function isSessionArchived(key) {
      return state.archivedSessions.includes(key);
    }
    
    // Parse session key to extract group info for nesting
    function parseSessionGroup(key) {
      // Match patterns like: agent:main:telegram:group:-1003814943696:topic:54
      const topicMatch = key.match(/^(agent:[^:]+:[^:]+:group:[^:]+):topic:(\d+)$/);
      if (topicMatch) {
        return {
          type: 'topic',
          groupKey: topicMatch[1],
          topicId: topicMatch[2],
          isGrouped: true
        };
      }
      // Match patterns like: agent:main:telegram:group:-1003814943696 (group without topic)
      const groupMatch = key.match(/^(agent:[^:]+:[^:]+:group:[^:]+)$/);
      if (groupMatch) {
        return {
          type: 'group',
          groupKey: groupMatch[1],
          isGrouped: false
        };
      }
      return { type: 'standalone', isGrouped: false };
    }
    
    function getGroupDisplayName(groupKey) {
      // Try to find a custom name for the group
      const customName = state.sessionNames[groupKey];
      if (customName) return customName;
      // Extract group ID and return a readable name
      const match = groupKey.match(/:group:(-?\d+)$/);
      if (match) {
        return `Group ${match[1]}`;
      }
      return groupKey.split(':').pop();
    }
    
    function toggleGroupExpanded(groupKey) {
      state.expandedGroups[groupKey] = !state.expandedGroups[groupKey];
      localStorage.setItem('sharp_expanded_groups', JSON.stringify(state.expandedGroups));
      renderSessions();
    }
    
    function isGroupExpanded(groupKey) {
      // Default to expanded
      return state.expandedGroups[groupKey] !== false;
    }
    
    function getGroupUnreadCount(groupKey, sessions) {
      return sessions.filter(s => {
        const parsed = parseSessionGroup(s.key);
        return parsed.groupKey === groupKey && isSessionUnread(s.key);
      }).length;
    }
    
    async function generateGroupTitles(groupKey, event) {
      if (event) event.stopPropagation();
      // Find all sessions in this group
      const groupSessions = state.sessions.filter(s => {
        const parsed = parseSessionGroup(s.key);
        return parsed.groupKey === groupKey && parsed.type === 'topic';
      });
      
      showToast(`Generating titles for ${groupSessions.length} topics...`);
      
      // Generate titles for each session that doesn't have a custom name
      for (const s of groupSessions) {
        if (!getCustomSessionName(s.key) && !state.generatingTitles.has(s.key)) {
          await generateSessionTitle(s.key);
          // Small delay between requests
          await new Promise(r => setTimeout(r, 500));
        }
      }
    }
    
    // Session status - brief current state (5-10 words)
    function getSessionStatus(key) {
      return state.sessionStatus[key] || null;
    }
    
    async function generateSessionStatusBrief(key, event) {
      if (event) event.stopPropagation();
      if (state.generatingStatus.has(key)) return;
      
      state.generatingStatus.add(key);
      renderSessions();
      
      try {
        const history = await rpcCall('chat.history', { sessionKey: key, limit: 5 });
        if (!history?.messages?.length) {
          state.generatingStatus.delete(key);
          return;
        }
        
        const context = history.messages
          .filter(m => m.role === 'user' || m.role === 'assistant')
          .map(m => `${m.role}: ${typeof m.content === 'string' ? m.content.slice(0, 150) : ''}`)
          .join('\n');
        
        const response = await fetch('/api/openai/v1/chat/completions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            model: 'gpt-4o-mini',
            messages: [
              { role: 'system', content: 'Write a 5-8 word status of what is currently happening. Be specific. No punctuation. Examples: "Adding unread indicators to Sharp sidebar", "Debugging Catastro API rate limits", "Waiting for user feedback on design"' },
              { role: 'user', content: context.slice(0, 1500) }
            ],
            max_tokens: 30,
            temperature: 0.3
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          const status = data.choices?.[0]?.message?.content?.trim();
          if (status && status.length < 80) {
            state.sessionStatus[key] = { text: status, updatedAt: Date.now() };
            localStorage.setItem('sharp_session_status', JSON.stringify(state.sessionStatus));
          }
        }
      } catch (err) {
        console.error('Status generation failed:', err);
      } finally {
        state.generatingStatus.delete(key);
        renderSessions();
      }
    }
    
    // Ask the session agent for a full summary
    async function askSessionForSummary(key, event) {
      if (event) event.stopPropagation();
      
      // Send message to the session asking for summary
      try {
        await rpcCall('chat.send', {
          sessionKey: key,
          message: 'Please give me a clean summary of our full conversation so far - what we discussed, what was accomplished, and current status.',
          idempotencyKey: `summary-request-${Date.now()}`
        });
        
        showToast('Asked session for summary - check the chat');
        // Open that session so user can see the response
        openSession(key);
      } catch (err) {
        console.error('Failed to ask for summary:', err);
        showToast('Failed to request summary', 'error');
      }
    }
    
    function renderSessionStatusLine(key) {
      const isGenerating = state.generatingStatus.has(key);
      const status = getSessionStatus(key);
      
      if (isGenerating) {
        return '<div class="item-status generating">â³</div>';
      }
      
      if (status?.text) {
        return `<div class="item-status" onclick="event.stopPropagation(); generateSessionStatusBrief('${escapeHtml(key)}')" title="Click to refresh">${escapeHtml(status.text)}</div>`;
      }
      
      return `<div class="item-status generate-link" onclick="event.stopPropagation(); generateSessionStatusBrief('${escapeHtml(key)}')">â†» status</div>`;
    }
    
    function isSessionUnread(key) {
      const session = state.sessions.find(s => s.key === key);
      if (!session) return false;
      const lastViewed = state.lastViewedAt[key] || 0;
      const updatedAt = session.updatedAt || 0;
      // Unread if updated since last viewed (with 1s grace period)
      return updatedAt > lastViewed + 1000;
    }
    
    function markSessionRead(key) {
      state.lastViewedAt[key] = Date.now();
      localStorage.setItem('sharp_last_viewed', JSON.stringify(state.lastViewedAt));
    }
    
    function markSessionUnread(key, event) {
      if (event) event.stopPropagation();
      // Set lastViewed to 0 so it appears unread
      state.lastViewedAt[key] = 0;
      localStorage.setItem('sharp_last_viewed', JSON.stringify(state.lastViewedAt));
      renderSessions();
      renderSessionsGrid();
    }
    
    function markAllSessionsRead() {
      const now = Date.now();
      state.sessions.forEach(s => {
        state.lastViewedAt[s.key] = now;
      });
      localStorage.setItem('sharp_last_viewed', JSON.stringify(state.lastViewedAt));
      renderSessions();
      renderSessionsGrid();
      showToast('All sessions marked as read');
    }
    
    function getUnreadCount() {
      return state.sessions.filter(s => isSessionUnread(s.key)).length;
    }
    
    function togglePinSession(key) {
      const idx = state.pinnedSessions.indexOf(key);
      if (idx >= 0) {
        state.pinnedSessions.splice(idx, 1);
      } else {
        state.pinnedSessions.push(key);
      }
      localStorage.setItem('sharp_pinned_sessions', JSON.stringify(state.pinnedSessions));
      renderSessions();
      renderSessionsGrid();
    }
    
    function toggleArchiveSession(key) {
      const idx = state.archivedSessions.indexOf(key);
      if (idx >= 0) {
        state.archivedSessions.splice(idx, 1);
      } else {
        state.archivedSessions.push(key);
        // Unpin if archived
        const pinIdx = state.pinnedSessions.indexOf(key);
        if (pinIdx >= 0) {
          state.pinnedSessions.splice(pinIdx, 1);
          localStorage.setItem('sharp_pinned_sessions', JSON.stringify(state.pinnedSessions));
        }
      }
      localStorage.setItem('sharp_archived_sessions', JSON.stringify(state.archivedSessions));
      renderSessions();
      renderSessionsGrid();
    }
    
    function toggleShowArchived() {
      state.showArchived = !state.showArchived;
      renderSessions();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SESSION RENAME
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function getCustomSessionName(key) {
      return state.sessionNames[key] || null;
    }
    
    function setCustomSessionName(key, name) {
      if (name && name.trim()) {
        state.sessionNames[key] = name.trim();
      } else {
        delete state.sessionNames[key];
      }
      localStorage.setItem('sharp_session_names', JSON.stringify(state.sessionNames));
      renderSessions();
      renderSessionsGrid();
    }
    
    function promptRenameSession(key, event) {
      if (event) event.stopPropagation();
      const session = state.sessions.find(s => s.key === key);
      const current = getCustomSessionName(key) || getDefaultSessionName(session);
      const newName = prompt('Rename session:', current);
      if (newName !== null) {
        setCustomSessionName(key, newName);
      }
    }
    
    async function generateSessionTitle(key, event) {
      if (event) event.stopPropagation();
      const session = state.sessions.find(s => s.key === key);
      if (!session) return;
      
      showToast('Generating title...', 'info', 3000);
      
      try {
        // Get first few messages from this session
        const historyResult = await rpcCall('chat.history', { sessionKey: key, limit: 5 });
        const messages = historyResult?.messages || [];
        
        if (messages.length === 0) {
          showToast('No messages to summarize', 'warning');
          return;
        }
        
        // Extract conversation context
        const conversation = messages.slice(0, 4).map(m => {
          const role = m.role === 'user' ? 'User' : 'Assistant';
          let content = '';
          if (typeof m.content === 'string') {
            content = m.content.slice(0, 150);
          } else if (Array.isArray(m.content)) {
            content = m.content
              .filter(c => c.type === 'text')
              .map(c => c.text)
              .join(' ')
              .slice(0, 150);
          }
          return `${role}: ${content}`;
        }).join('\n');
        
        if (!conversation.trim()) {
          showToast('No content to summarize', 'warning');
          return;
        }
        
        // Try LLM-based title generation
        const title = await generateTitleWithLLM(conversation);
        
        if (title) {
          setCustomSessionName(key, title);
          showToast(`Titled: "${title}"`, 'success');
        } else {
          showToast('Could not generate title', 'warning');
        }
      } catch (err) {
        console.error('Failed to generate title:', err);
        showToast('Failed to generate title', 'error');
      }
    }
    
    async function generateTitleWithLLM(conversation) {
      try {
        // Use server-side proxy that injects the API key
        const response = await fetch('/api/openai/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            model: 'gpt-4o-mini',
            messages: [
              {
                role: 'system',
                content: 'Generate a very short title (3-6 words) for this conversation. Reply with ONLY the title, no quotes, no punctuation at the end.'
              },
              {
                role: 'user',
                content: conversation
              }
            ],
            max_tokens: 20,
            temperature: 0.3
          })
        });
        
        if (!response.ok) {
          console.error('OpenAI API error:', response.status);
          return null;
        }
        
        const data = await response.json();
        const title = data.choices?.[0]?.message?.content?.trim();
        
        if (title && title.length < 60) {
          return title.replace(/^["']|["']$/g, '').replace(/\.+$/, '');
        }
        return null;
      } catch (err) {
        console.error('LLM title generation failed:', err);
        return null;
      }
    }
    
    // OpenAI API key is injected server-side via /api/openai proxy
    
    async function autoGenerateTitle(key) {
      // Mark as attempted to avoid retries
      state.attemptedTitles.add(key);
      state.generatingTitles.add(key);
      renderSessions();
      
      try {
        const session = state.sessions.find(s => s.key === key);
        if (!session) return;
        
        // Get messages
        const historyResult = await rpcCall('chat.history', { sessionKey: key, limit: 5 });
        const messages = historyResult?.messages || [];
        
        if (messages.length === 0) {
          state.generatingTitles.delete(key);
          renderSessions();
          return;
        }
        
        // Extract conversation
        const conversation = messages.slice(0, 4).map(m => {
          const role = m.role === 'user' ? 'User' : 'Assistant';
          let content = '';
          if (typeof m.content === 'string') {
            content = m.content.slice(0, 150);
          } else if (Array.isArray(m.content)) {
            content = m.content
              .filter(c => c.type === 'text')
              .map(c => c.text)
              .join(' ')
              .slice(0, 150);
          }
          return `${role}: ${content}`;
        }).join('\n');
        
        if (!conversation.trim()) {
          state.generatingTitles.delete(key);
          renderSessions();
          return;
        }
        
        // Generate title
        const title = await generateTitleWithLLM(conversation);
        
        state.generatingTitles.delete(key);
        
        if (title) {
          // Animate the title with typewriter effect
          setCustomSessionName(key, title);
          animateTitle(key, title);
        } else {
          renderSessions();
        }
      } catch (err) {
        console.error('Auto-generate title failed:', err);
        state.generatingTitles.delete(key);
        renderSessions();
      }
    }
    
    function animateTitle(key, title) {
      // Find the session name element and animate it
      const el = document.querySelector(`[data-session-key="${key}"] .item-name`);
      if (el) {
        el.innerHTML = '';
        el.className = 'item-name title-typewriter';
        let i = 0;
        const interval = setInterval(() => {
          if (i < title.length) {
            el.textContent += title[i];
            i++;
          } else {
            clearInterval(interval);
            el.className = 'item-name';
          }
        }, 30);
      } else {
        renderSessions();
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SESSION SEARCH
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function handleSearchInput(value) {
      state.searchQuery = value.toLowerCase().trim();
      renderSessions();
    }
    
    function clearSearch() {
      state.searchQuery = '';
      document.getElementById('sessionSearchInput').value = '';
      renderSessions();
    }
    
    function handleSearchKeydown(event) {
      if (event.key === 'Escape') {
        clearSearch();
        document.getElementById('sessionSearchInput').blur();
      } else if (event.key === 'Enter') {
        // Select first visible session
        const firstSession = document.querySelector('#sessionsList .item');
        if (firstSession) firstSession.click();
      }
    }
    
    function matchesSearch(session) {
      if (!state.searchQuery) return true;
      const q = state.searchQuery;
      // Match against name, key, label, displayName
      const name = getSessionName(session).toLowerCase();
      const key = session.key.toLowerCase();
      const label = (session.label || '').toLowerCase();
      const displayName = (session.displayName || '').toLowerCase();
      return name.includes(q) || key.includes(q) || label.includes(q) || displayName.includes(q);
    }
    
    // Keyboard shortcut: Cmd/Ctrl+K to focus search
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        document.getElementById('sessionSearchInput')?.focus();
      }
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AUTO-ARCHIVE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function setAutoArchiveDays(value) {
      state.autoArchiveDays = value;
      localStorage.setItem('sharp_auto_archive_days', value);
      console.log('[Sharp] Auto-archive set to:', value);
    }
    
    function initAutoArchiveUI() {
      const select = document.getElementById('autoArchiveSelect');
      if (select) {
        select.value = state.autoArchiveDays;
      }
    }
    
    function checkAutoArchive() {
      // Skip if auto-archive is disabled
      if (state.autoArchiveDays === 'never') {
        console.log('[Sharp] Auto-archive disabled');
        return;
      }
      
      const days = parseFloat(state.autoArchiveDays);
      if (isNaN(days) || days <= 0) return;
      
      const threshold = Date.now() - (days * 24 * 60 * 60 * 1000);
      let autoArchivedCount = 0;
      
      for (const session of state.sessions) {
        // Skip if already archived
        if (isSessionArchived(session.key)) continue;
        
        // Skip pinned sessions (they're important)
        if (isSessionPinned(session.key)) continue;
        
        // Check if session is inactive beyond threshold
        const updatedAt = session.updatedAt || 0;
        if (updatedAt > 0 && updatedAt < threshold) {
          // Auto-archive this session
          state.archivedSessions.push(session.key);
          autoArchivedCount++;
          console.log('[Sharp] Auto-archived:', session.key, 'last updated:', new Date(updatedAt).toISOString());
        }
      }
      
      // Save if any were archived
      if (autoArchivedCount > 0) {
        localStorage.setItem('sharp_archived_sessions', JSON.stringify(state.archivedSessions));
        showToast(`Auto-archived ${autoArchivedCount} inactive session${autoArchivedCount > 1 ? 's' : ''}`, 'info');
        renderSessions();
        renderSessionsGrid();
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TOAST NOTIFICATIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function showToast(message, type = 'info', durationMs = 4000) {
      const container = document.getElementById('toastContainer');
      if (!container) return;
      
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      
      const icon = type === 'success' ? 'âœ“' : type === 'warning' ? 'âš ' : 'â„¹';
      toast.innerHTML = `<span>${icon}</span><span>${escapeHtml(message)}</span>`;
      
      container.appendChild(toast);
      
      // Auto-remove after duration
      setTimeout(() => {
        toast.classList.add('hiding');
        setTimeout(() => toast.remove(), 300);
      }, durationMs);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WEBSOCKET CONNECTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function connectWebSocket() {
      if (state.ws) {
        state.ws.close();
        state.ws = null;
      }
      
      state.connectNonce = null;
      state.connectSent = false;
      setConnectionStatus('connecting');
      
      // Build WebSocket URL - use /ws path for Caddy proxy
      let wsUrl = state.gatewayUrl.replace(/^http/, 'ws');
      // If connecting through Caddy (port 9000 or no port), use /ws endpoint
      if (!wsUrl.includes(':18789')) {
        wsUrl = wsUrl.replace(/\/?$/, '/ws');
      }
      console.log('[WS] Connecting to', wsUrl);
      
      try {
        state.ws = new WebSocket(wsUrl);
      } catch (err) {
        console.error('[WS] Failed to create WebSocket:', err);
        setConnectionStatus('error');
        scheduleReconnect();
        return;
      }
      
      state.ws.onopen = () => {
        console.log('[WS] Socket opened, waiting for challenge...');
        state.wsLastMessageAt = Date.now();
      };
      
      state.ws.onmessage = (event) => {
        state.wsLastMessageAt = Date.now();
        resetStaleTimer();
        
        try {
          const msg = JSON.parse(event.data);
          handleWsMessage(msg);
        } catch (err) {
          console.error('[WS] Parse error:', err);
        }
      };
      
      state.ws.onerror = (err) => {
        console.error('[WS] Error:', err);
      };
      
      state.ws.onclose = (event) => {
        console.log('[WS] Closed:', event.code, event.reason);
        state.connected = false;
        state.ws = null;
        state.connectNonce = null;
        state.connectSent = false;
        clearWsTimers();
        setConnectionStatus('error');
        
        for (const [id, pending] of state.rpcPending) {
          clearTimeout(pending.timeout);
          pending.reject(new Error('WebSocket closed'));
        }
        state.rpcPending.clear();
        
        scheduleReconnect();
      };
    }
    
    function handleWsMessage(msg) {
      // Debug: log all incoming messages
      if (msg.type === 'event') {
        console.log('[Sharp] WS Event:', msg.event, msg.payload ? JSON.stringify(msg.payload).slice(0, 200) : '');
      }
      
      // Challenge for auth (comes as event type)
      if (msg.type === 'event' && msg.event === 'connect.challenge') {
        state.connectNonce = msg.payload?.nonce;
        // Auto-connect (password hardcoded for Tailscale-only access)
        sendConnect();
        return;
      }
      
      // RPC response
      if (msg.type === 'res' && msg.id) {
        const pending = state.rpcPending.get(msg.id);
        if (pending) {
          state.rpcPending.delete(msg.id);
          clearTimeout(pending.timeout);
          
          if (msg.error) {
            pending.reject(new Error(msg.error?.message || 'RPC failed'));
          } else {
            pending.resolve(msg.payload ?? msg.result);
          }
        }
        return;
      }
      
      // Chat events (streaming)
      if (msg.type === 'event' && msg.event === 'chat') {
        handleChatEvent(msg.payload);
        return;
      }
      
      // Agent lifecycle events (for typing indicator)
      if (msg.type === 'event' && msg.event === 'agent') {
        handleAgentEvent(msg.payload);
        return;
      }
    }
    
    function sendConnect() {
      if (state.connectSent || !state.ws) return;
      state.connectSent = true;
      
      const connectId = String(++state.rpcIdCounter);
      
      const connectParams = {
        minProtocol: WS_PROTOCOL_VERSION,
        maxProtocol: WS_PROTOCOL_VERSION,
        client: {
          id: 'clawdbot-control-ui',
          displayName: 'Sharp Dashboard',
          mode: 'ui',
          version: '2.0.0',
          platform: 'browser'
        }
      };
      
      // Only include auth if we have a token (Caddy proxy handles auth otherwise)
      if (state.token) {
        connectParams.auth = { password: state.token };
      }
      
      const connectFrame = {
        type: 'req',
        id: connectId,
        method: 'connect',
        params: connectParams
      };
      
      console.log('[WS] Sending connect request');
      state.ws.send(JSON.stringify(connectFrame));
      
      const timeout = setTimeout(() => {
        state.rpcPending.delete(connectId);
        console.error('[WS] Connect timeout');
        state.ws?.close(1008, 'connect timeout');
      }, 10000);
      
      state.rpcPending.set(connectId, {
        resolve: (result) => {
          console.log('[WS] Connected successfully');
          state.connected = true;
          state.wsReconnectAttempts = 0;
          setConnectionStatus('connected');
          hideReconnectOverlay();
          localStorage.setItem('sharp_token', state.token);
          localStorage.setItem('sharp_gateway', state.gatewayUrl);
          hideLoginModal();
          startKeepalive();
          loadInitialData();
        },
        reject: (err) => {
          console.error('[WS] Connect failed:', err);
          state.connectSent = false;
          setConnectionStatus('error');
          showLoginModal();
          const errorDiv = document.getElementById('loginError');
          if (errorDiv) {
            errorDiv.textContent = err.message || 'Authentication failed';
            errorDiv.style.display = 'block';
          }
        },
        timeout
      });
    }
    
    function handleAgentEvent(data) {
      const { sessionKey, runId, stream, data: eventData } = data;
      
      // Show typing indicator when agent starts working
      if (stream === 'lifecycle' && eventData?.phase === 'start') {
        if (state.currentSession?.key === sessionKey) {
          showTypingIndicator(runId);
        }
        // Also set thinking status
        trackActiveRun(sessionKey, runId);
        state.sessionInputReady.set(sessionKey, false);
        if (state.sessionStatus[sessionKey] !== 'thinking') {
          setSessionStatus(sessionKey, 'thinking');
        }
      }
      
      // Hide typing indicator when agent ends
      if (stream === 'lifecycle' && eventData?.phase === 'end') {
        hideTypingIndicator(runId);
      }
      
      // Show tool calls via compact activity indicator
      if (stream === 'tool' && state.currentSession?.key === sessionKey) {
        const toolCallId = eventData?.toolCallId || `${runId}-${eventData?.name}-${Date.now()}`;
        const toolName = eventData?.name || eventData?.tool || 'tool';
        const toolInput = eventData?.input || eventData?.args || '';
        const toolOutput = eventData?.output || eventData?.result || '';
        
        if (eventData?.phase === 'start' || eventData?.type === 'call') {
          trackToolStart(runId, toolCallId, toolName, toolInput);
        } else if (eventData?.phase === 'end' || eventData?.phase === 'result' || eventData?.type === 'result') {
          trackToolEnd(runId, toolCallId, toolName, toolOutput);
        }
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COMPACT TOOL ACTIVITY INDICATOR
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function getToolIcon(toolName) {
      const name = (toolName || '').toLowerCase();
      if (name.includes('read') || name.includes('file')) return 'ğŸ“„';
      if (name.includes('write') || name.includes('edit')) return 'âœï¸';
      if (name.includes('exec') || name.includes('bash') || name.includes('shell')) return 'âš¡';
      if (name.includes('browser') || name.includes('web')) return 'ğŸŒ';
      if (name.includes('search')) return 'ğŸ”';
      if (name.includes('image')) return 'ğŸ–¼ï¸';
      if (name.includes('message') || name.includes('send')) return 'ğŸ’¬';
      if (name.includes('cron') || name.includes('schedule')) return 'â°';
      if (name.includes('memory')) return 'ğŸ§ ';
      return 'ğŸ”§';
    }
    
    function trackToolStart(runId, toolCallId, toolName, input) {
      hideTypingIndicator(runId);
      
      state.activeTools.set(toolCallId, {
        runId,
        name: toolName,
        args: input,
        output: null,
        startedAt: Date.now(),
        status: 'running'
      });
      
      renderToolActivity();
      scrollChatToBottom();
    }
    
    function trackToolEnd(runId, toolCallId, toolName, output) {
      // Find by toolCallId or by name (fallback)
      let tool = state.activeTools.get(toolCallId);
      if (!tool) {
        // Fallback: find most recent tool with same name
        for (const [id, t] of state.activeTools) {
          if (t.name === toolName && t.status === 'running') {
            toolCallId = id;
            tool = t;
            break;
          }
        }
      }
      
      if (tool) {
        tool.output = output;
        tool.status = 'done';
        tool.endedAt = Date.now();
        state.activeTools.set(toolCallId, tool);
      }
      
      renderToolActivity();
      
      // Clear completed tools after a delay (keep them visible briefly)
      setTimeout(() => {
        cleanupCompletedTools(runId);
      }, 3000);
    }
    
    function cleanupCompletedTools(runId) {
      // Only clean up if all tools for this run are done
      let allDone = true;
      for (const [id, tool] of state.activeTools) {
        if (tool.runId === runId && tool.status === 'running') {
          allDone = false;
          break;
        }
      }
      
      if (allDone) {
        // Remove all tools for this run
        for (const [id, tool] of state.activeTools) {
          if (tool.runId === runId) {
            state.activeTools.delete(id);
          }
        }
        renderToolActivity();
      }
    }
    
    function clearAllTools() {
      state.activeTools.clear();
      state.toolActivityExpanded = false;
      const el = document.getElementById('toolActivityIndicator');
      if (el) el.remove();
    }
    
    function toggleToolActivityExpanded() {
      state.toolActivityExpanded = !state.toolActivityExpanded;
      const el = document.getElementById('toolActivityIndicator');
      if (el) {
        el.classList.toggle('expanded', state.toolActivityExpanded);
      }
    }
    
    function renderToolActivity() {
      const container = document.getElementById('chatMessages');
      if (!container) return;
      
      let el = document.getElementById('toolActivityIndicator');
      
      // If no active tools, remove the indicator
      if (state.activeTools.size === 0) {
        if (el) el.remove();
        return;
      }
      
      // Count running vs done
      let runningCount = 0;
      let doneCount = 0;
      const tools = Array.from(state.activeTools.values());
      tools.forEach(t => t.status === 'running' ? runningCount++ : doneCount++);
      
      // Build pills HTML
      const pillsHtml = tools.slice(-5).map(t => {
        const icon = getToolIcon(t.name);
        const statusClass = t.status === 'done' ? 'done' : '';
        return `<span class="tool-activity-pill ${statusClass}">
          <span class="pill-icon">${icon}</span>
          <span>${escapeHtml(t.name)}</span>
        </span>`;
      }).join('');
      
      // Build details HTML
      const detailsHtml = tools.map(t => {
        const icon = getToolIcon(t.name);
        const statusClass = t.status === 'running' ? 'running' : 'done';
        const statusText = t.status === 'running' ? 'â³ running' : 'âœ“ done';
        const argsStr = t.args ? (typeof t.args === 'string' ? t.args : JSON.stringify(t.args, null, 2)) : '';
        const outputStr = t.output ? (typeof t.output === 'string' ? t.output : JSON.stringify(t.output, null, 2)) : '';
        const contentStr = outputStr ? `${argsStr}\n\n--- Result ---\n${outputStr}` : argsStr;
        
        return `<div class="tool-activity-item">
          <div class="tool-activity-item-header">
            <span class="tool-activity-item-icon">${icon}</span>
            <span class="tool-activity-item-name">${escapeHtml(t.name)}</span>
            <span class="tool-activity-item-status ${statusClass}">${statusText}</span>
          </div>
          ${contentStr ? `<div class="tool-activity-item-content collapsed">${escapeHtml(contentStr)}</div>` : ''}
        </div>`;
      }).join('');
      
      const labelText = runningCount > 0 
        ? `Working... (${runningCount} active${doneCount > 0 ? `, ${doneCount} done` : ''})`
        : `${doneCount} tool${doneCount !== 1 ? 's' : ''} completed`;
      
      const showSpinner = runningCount > 0;
      
      if (!el) {
        el = document.createElement('div');
        el.id = 'toolActivityIndicator';
        el.className = 'tool-activity';
        container.appendChild(el);
      }
      
      if (state.toolActivityExpanded) {
        el.classList.add('expanded');
      }
      
      el.innerHTML = `
        <div class="tool-activity-header" onclick="toggleToolActivityExpanded()">
          ${showSpinner ? '<div class="tool-activity-spinner"></div>' : '<span style="color: var(--green);">âœ“</span>'}
          <span class="tool-activity-label">${labelText}</span>
          <div class="tool-activity-tools">${pillsHtml}</div>
          <span class="tool-activity-expand">â–¼</span>
        </div>
        <div class="tool-activity-details">${detailsHtml}</div>
      `;
      
      scrollChatToBottom();
    }
    
    // Legacy function for compatibility - now uses compact indicator
    function addToolCall(runId, toolName, input) {
      const toolCallId = `${runId}-${toolName}-${Date.now()}`;
      trackToolStart(runId, toolCallId, toolName, input);
    }
    
    function updateToolCallResult(runId, toolName, output) {
      // Find most recent tool with this name
      for (const [id, tool] of state.activeTools) {
        if (tool.name === toolName && tool.status === 'running') {
          trackToolEnd(runId, id, toolName, output);
          return;
        }
      }
      // Fallback: legacy behavior
      const toolCalls = document.querySelectorAll('.tool-call');
      for (let i = toolCalls.length - 1; i >= 0; i--) {
        const nameEl = toolCalls[i].querySelector('.tool-call-name');
        if (nameEl && nameEl.textContent === toolName) {
          const contentEl = toolCalls[i].querySelector('.tool-call-content pre');
          if (contentEl) {
            const outputStr = typeof output === 'string' ? output : JSON.stringify(output, null, 2);
            contentEl.textContent += '\n\n--- Result ---\n' + outputStr;
          }
          break;
        }
      }
    }
    
    function handleChatEvent(data) {
      const { sessionKey, runId, state: runState, message } = data;
      
      console.log('[Sharp] Chat event:', runState, 'for', sessionKey, 'runId:', runId);
      
      // Server sends: 'delta' (streaming), 'final' (done), 'error'
      // Track active runs and update agent status (with persistence)
      if (runState === 'delta') {
        // Streaming chunk - agent is thinking/responding
        trackActiveRun(sessionKey, runId);
        state.sessionInputReady.set(sessionKey, false);
        if (state.sessionStatus[sessionKey] !== 'thinking') {
          setSessionStatus(sessionKey, 'thinking');
        }
        
        // Show streaming content in current session
        if (state.currentSession?.key === sessionKey && message?.content) {
          const text = extractText(message.content);
          if (text) {
            updateStreamingMessage(runId, text);
          }
        }
      } else if (runState === 'final') {
        // Response complete
        clearActiveRun(sessionKey);
        state.sessionInputReady.set(sessionKey, true);
        setSessionStatus(sessionKey, 'idle');
        
        if (state.currentSession?.key === sessionKey) {
          state.isThinking = false;
          updateSendButton();
          
          // Clear tool activity indicator after brief delay
          setTimeout(() => clearAllTools(), 2000);
          
          // Finalize streaming message or add new one
          if (message?.content) {
            const text = extractText(message.content);
            if (text) {
              finalizeStreamingMessage(runId, text);
            }
          } else {
            // No content in final, just remove thinking indicator
            removeStreamingMessage(runId);
          }
        }
      } else if (runState === 'error' || runState === 'aborted') {
        clearActiveRun(sessionKey);
        state.sessionInputReady.set(sessionKey, true);
        setSessionStatus(sessionKey, runState === 'error' ? 'error' : 'idle');
        
        if (state.currentSession?.key === sessionKey) {
          state.isThinking = false;
          updateSendButton();
          removeStreamingMessage(runId);
          clearAllTools();  // Clear tool activity on error/abort
          if (data.errorMessage) {
            addChatMessage('system', `Error: ${data.errorMessage}`);
          }
        }
      }
    }
    
    // Typing indicator (bouncing dots)
    function showTypingIndicator(runId) {
      // Don't show if already have streaming content
      if (document.getElementById(`streaming-${runId}`)) return;
      
      let el = document.getElementById(`typing-${runId}`);
      if (el) return; // Already showing
      
      const container = document.getElementById('chatMessages');
      if (!container) return;
      
      el = document.createElement('div');
      el.id = `typing-${runId}`;
      el.className = 'typing-indicator';
      el.innerHTML = '<div class="dot"></div><div class="dot"></div><div class="dot"></div>';
      container.appendChild(el);
      scrollChatToBottom();
    }
    
    function hideTypingIndicator(runId) {
      const el = document.getElementById(`typing-${runId}`);
      if (el) el.remove();
    }
    
    // Streaming message management
    function updateStreamingMessage(runId, text) {
      // Hide typing indicator when content arrives
      hideTypingIndicator(runId);
      
      let el = document.getElementById(`streaming-${runId}`);
      if (!el) {
        // Remove old thinking indicator
        const thinking = document.querySelector('.message.thinking');
        if (thinking) thinking.remove();
        
        // Create streaming message element
        const container = document.getElementById('chatMessages');
        el = document.createElement('div');
        el.id = `streaming-${runId}`;
        el.className = 'message assistant streaming';
        el.dataset.startTime = Date.now();
        container.appendChild(el);
      }
      el.innerHTML = `<div class="message-content">${formatMessage(text)}<span class="streaming-cursor">â–Š</span></div>`;
      scrollChatToBottom();
    }
    
    function finalizeStreamingMessage(runId, text) {
      const el = document.getElementById(`streaming-${runId}`);
      if (el) {
        el.classList.remove('streaming');
        const timeStr = formatMessageTime(new Date());
        el.innerHTML = `<div class="message-content">${formatMessage(text)}</div><div class="message-time">${timeStr}</div>`;
      } else if (text) {
        // No streaming element, add final message
        const thinking = document.querySelector('.message.thinking');
        if (thinking) thinking.remove();
        addChatMessage('assistant', text);
      }
    }
    
    function removeStreamingMessage(runId) {
      const el = document.getElementById(`streaming-${runId}`);
      if (el) el.remove();
      hideTypingIndicator(runId);
      const thinking = document.querySelector('.message.thinking');
      if (thinking) thinking.remove();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RPC
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function rpcCall(method, params = {}, timeoutMs = 30000) {
      return new Promise((resolve, reject) => {
        if (!state.connected || !state.ws) {
          reject(new Error('WebSocket not connected'));
          return;
        }
        
        const id = String(++state.rpcIdCounter);
        const frame = { type: 'req', id, method, params };
        
        const timeout = setTimeout(() => {
          state.rpcPending.delete(id);
          reject(new Error('RPC timeout'));
        }, timeoutMs);
        
        state.rpcPending.set(id, { resolve, reject, timeout });
        state.ws.send(JSON.stringify(frame));
      });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TIMERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function clearWsTimers() {
      if (state.wsReconnectTimer) {
        clearTimeout(state.wsReconnectTimer);
        state.wsReconnectTimer = null;
      }
      if (state.wsKeepaliveTimer) {
        clearInterval(state.wsKeepaliveTimer);
        state.wsKeepaliveTimer = null;
      }
      if (state.wsStaleTimer) {
        clearTimeout(state.wsStaleTimer);
        state.wsStaleTimer = null;
      }
    }
    
    function scheduleReconnect() {
      if (state.wsReconnectTimer) return;
      
      const delay = RECONNECT_DELAYS[Math.min(state.wsReconnectAttempts, RECONNECT_DELAYS.length - 1)];
      state.wsReconnectAttempts++;
      
      // Show reconnect overlay
      showReconnectOverlay(state.wsReconnectAttempts);
      
      console.log(`[WS] Reconnecting in ${delay}ms (attempt ${state.wsReconnectAttempts})`);
      state.wsReconnectTimer = setTimeout(() => {
        state.wsReconnectTimer = null;
        connectWebSocket();
      }, delay);
    }
    
    function showReconnectOverlay(attempt) {
      const overlay = document.getElementById('reconnectOverlay');
      const attemptEl = document.getElementById('reconnectAttempt');
      if (overlay) {
        overlay.classList.add('visible');
        if (attemptEl) attemptEl.textContent = `Attempt ${attempt}`;
      }
    }
    
    function hideReconnectOverlay() {
      const overlay = document.getElementById('reconnectOverlay');
      if (overlay) overlay.classList.remove('visible');
    }
    
    function startKeepalive() {
      if (state.wsKeepaliveTimer) clearInterval(state.wsKeepaliveTimer);
      
      state.wsKeepaliveTimer = setInterval(() => {
        if (state.connected && state.ws) {
          state.ws.send(JSON.stringify({ type: 'req', id: 'keepalive', method: 'status', params: {} }));
        }
      }, 25000);
    }
    
    function resetStaleTimer() {
      if (state.wsStaleTimer) clearTimeout(state.wsStaleTimer);
      
      state.wsStaleTimer = setTimeout(() => {
        const sinceLastMessage = Date.now() - state.wsLastMessageAt;
        if (sinceLastMessage > 60000) {
          console.log('[WS] Connection stale, reconnecting...');
          state.ws?.close(1000, 'stale');
        }
      }, 65000);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONNECTION STATUS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function setConnectionStatus(status) {
      const dot = document.getElementById('connectionDot');
      const text = document.getElementById('connectionText');
      
      switch (status) {
        case 'connected':
          dot.style.background = 'var(--green)';
          text.textContent = 'Connected';
          // Clear offline status for all sessions when reconnected
          for (const key of Object.keys(state.sessionStatus)) {
            if (state.sessionStatus[key] === 'offline') {
              state.sessionStatus[key] = 'idle';
            }
          }
          break;
        case 'connecting':
          dot.style.background = 'var(--yellow)';
          text.textContent = 'Connecting...';
          break;
        case 'error':
          dot.style.background = 'var(--red)';
          text.textContent = 'Disconnected';
          // Set all sessions to offline when disconnected
          for (const key of Object.keys(state.sessionStatus)) {
            state.sessionStatus[key] = 'offline';
          }
          renderSessions();
          updateHeaderStatus();
          break;
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AGENT STATUS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Persist active runs to localStorage so we can restore on page load
    const ACTIVE_RUN_STALE_MS = 5 * 60 * 1000; // 5 minutes - consider run stale if no updates
    
    function saveActiveRuns() {
      const obj = {};
      for (const [key, data] of Object.entries(state.activeRunsStore)) {
        obj[key] = data;
      }
      localStorage.setItem('sharp_active_runs', JSON.stringify(obj));
    }
    
    function restoreActiveRuns() {
      // Restore from localStorage and clean stale entries
      const now = Date.now();
      const store = state.activeRunsStore;
      let changed = false;
      
      for (const [key, data] of Object.entries(store)) {
        const age = now - (data.startedAt || 0);
        if (age > ACTIVE_RUN_STALE_MS) {
          // Stale run - remove it
          delete store[key];
          changed = true;
          console.log(`[Sharp] Cleaned stale run for ${key} (${Math.round(age/1000)}s old)`);
        } else {
          // Valid run - restore to activeRuns Map
          state.activeRuns.set(key, data.runId);
          state.sessionStatus[key] = 'thinking';
          console.log(`[Sharp] Restored active run for ${key}`);
        }
      }
      
      if (changed) {
        saveActiveRuns();
      }
    }
    
    function trackActiveRun(sessionKey, runId) {
      state.activeRuns.set(sessionKey, runId);
      state.activeRunsStore[sessionKey] = { runId, startedAt: Date.now() };
      saveActiveRuns();
    }
    
    function clearActiveRun(sessionKey) {
      state.activeRuns.delete(sessionKey);
      delete state.activeRunsStore[sessionKey];
      saveActiveRuns();
    }
    
    function setSessionStatus(key, status) {
      state.sessionStatus[key] = status;
      renderSessions();
      renderSessionsGrid();
      updateHeaderStatus();
    }
    
    function getAgentStatus(key) {
      return state.sessionStatus[key] || 'idle';
    }
    
    function getStatusTooltip(status) {
      switch (status) {
        case 'idle': return 'Ready';
        case 'thinking': return 'Processing...';
        case 'error': return 'Last request failed';
        case 'offline': return 'Disconnected';
        default: return status;
      }
    }
    
    function updateHeaderStatus() {
      const indicator = document.getElementById('headerStatusIndicator');
      if (!indicator || !state.currentSession) return;
      
      const status = getAgentStatus(state.currentSession.key);
      indicator.className = 'header-status ' + status;
      indicator.setAttribute('data-tooltip', getStatusTooltip(status));
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LOGIN
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function showLoginModal() {
      document.getElementById('loginModal').classList.remove('hidden');
      document.getElementById('loginPassword').focus();
    }
    
    function hideLoginModal() {
      document.getElementById('loginModal').classList.add('hidden');
      document.getElementById('loginError').style.display = 'none';
    }
    
    function doLogin() {
      const password = document.getElementById('loginPassword').value.trim();
      if (!password) return;
      
      state.token = password;
      state.connectSent = false;
      
      // Save to localStorage for future sessions
      localStorage.setItem('sharp_token', password);
      
      if (state.ws && state.connectNonce) {
        sendConnect();
      } else {
        connectWebSocket();
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DATA LOADING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async function loadInitialData() {
      console.log('[Sharp] loadInitialData starting - v2');
      try {
        // Fetch active runs from server first (authoritative source)
        console.log('[Sharp] About to call syncActiveRunsFromServer...');
        await syncActiveRunsFromServer();
        console.log('[Sharp] syncActiveRunsFromServer completed');
        await Promise.all([loadSessions(), loadApps(), loadAgents()]);
        updateOverview();
        
        // Restore previous session if any
        const savedSessionKey = localStorage.getItem('sharp_current_session');
        if (savedSessionKey) {
          const session = state.sessions.find(s => s.key === savedSessionKey);
          if (session) {
            console.log('[Sharp] Restoring session:', savedSessionKey);
            openSession(savedSessionKey);
          }
        }
      } catch (err) {
        console.error('Failed to load initial data:', err);
      }
    }
    
    async function syncActiveRunsFromServer() {
      try {
        console.log('[Sharp] Calling chat.activeRuns...');
        const result = await rpcCall('chat.activeRuns', {});
        console.log('[Sharp] chat.activeRuns response:', JSON.stringify(result));
        if (result?.activeRuns) {
          console.log('[Sharp] Synced active runs from server:', result.activeRuns.length);
          
          // Clear old state and sync with server
          state.activeRuns.clear();
          state.activeRunsStore = {};
          
          for (const run of result.activeRuns) {
            console.log('[Sharp] Setting thinking for:', run.sessionKey);
            state.activeRuns.set(run.sessionKey, run.runId);
            state.activeRunsStore[run.sessionKey] = {
              runId: run.runId,
              startedAt: run.startedAtMs
            };
            state.sessionStatus[run.sessionKey] = 'thinking';
          }
          
          saveActiveRuns();
          renderSessions();
          renderSessionsGrid();
        } else {
          console.log('[Sharp] No activeRuns in response, result:', result);
        }
      } catch (err) {
        console.error('[Sharp] chat.activeRuns error:', err);
        // Fallback to localStorage restore (for older Clawdbot versions)
        restoreActiveRuns();
      }
    }
    
    async function refresh() {
      if (!state.connected) return;
      
      // Clean up stale runs periodically (in case we missed 'done' events)
      cleanStaleRuns();
      
      await loadSessions();
      updateOverview();
    }
    
    function cleanStaleRuns() {
      const now = Date.now();
      let changed = false;
      
      for (const [key, data] of Object.entries(state.activeRunsStore)) {
        const age = now - (data.startedAt || 0);
        if (age > ACTIVE_RUN_STALE_MS) {
          console.log(`[Sharp] Cleaning stale run for ${key} (${Math.round(age/1000)}s old)`);
          state.activeRuns.delete(key);
          delete state.activeRunsStore[key];
          // Reset status to idle if it was thinking
          if (state.sessionStatus[key] === 'thinking') {
            state.sessionStatus[key] = 'idle';
          }
          changed = true;
        }
      }
      
      if (changed) {
        saveActiveRuns();
        renderSessions();
        renderSessionsGrid();
      }
    }
    
    async function loadSessions() {
      try {
        console.log('[Sharp] Loading sessions...');
        const result = await rpcCall('sessions.list', { limit: 50 });
        console.log('[Sharp] Sessions result:', result);
        if (result?.sessions) {
          state.sessions = result.sessions;
          // Initialize/update status for sessions
          for (const s of state.sessions) {
            // Active runs take priority (restored from localStorage or from WebSocket events)
            if (state.activeRuns.has(s.key)) {
              state.sessionStatus[s.key] = 'thinking';
            } else if (!state.sessionStatus[s.key]) {
              // Default to idle for new sessions
              state.sessionStatus[s.key] = 'idle';
            }
          }
          // Check for auto-archiving before rendering
          checkAutoArchive();
          renderSessions();
          renderSessionsGrid();
        }
      } catch (err) {
        console.error('[Sharp] Failed to load sessions:', err);
      }
    }
    
    async function loadApps() {
      try {
        const res = await fetch('/api/apps');
        if (!res.ok) return;
        const text = await res.text();
        if (!text) return;
        const data = JSON.parse(text);
        state.apps = data.apps || [];
        renderApps();
        state.apps.forEach(checkAppStatus);
      } catch (err) {
        console.error('Failed to load apps:', err);
      }
    }
    
    async function loadAgents() {
      try {
        const result = await rpcCall('agents.list', {});
        if (result?.agents) {
          state.agents = result.agents;
          renderAgents();
        }
      } catch (err) {
        console.error('Failed to load agents:', err);
      }
    }
    
    function renderAgents() {
      const container = document.getElementById('agentsList');
      
      if (state.agents.length === 0) {
        container.innerHTML = `<div style="padding: 16px; color: var(--text-dim); font-size: 0.85rem;">No agents configured</div>`;
        return;
      }
      
      container.innerHTML = state.agents.map(agent => {
        const emoji = agent.identity?.emoji || 'ğŸ¤–';
        const name = agent.identity?.name || agent.name || agent.id;
        const isDefault = agent.isDefault ? ' (default)' : '';
        return `
          <div class="item" onclick="showAgentDetails('${escapeHtml(agent.id)}')">
            <div class="item-icon">${emoji}</div>
            <div class="item-content">
              <div class="item-name">${escapeHtml(name)}${isDefault}</div>
              <div class="item-meta">${escapeHtml(agent.id)}</div>
            </div>
            <button class="item-action" onclick="event.stopPropagation(); startNewSession('${escapeHtml(agent.id)}')" title="New session">+</button>
          </div>
        `;
      }).join('');
    }
    
    function showAgentDetails(agentId) {
      const agent = state.agents.find(a => a.id === agentId);
      if (!agent) return;
      
      const emoji = agent.identity?.emoji || 'ğŸ¤–';
      const name = agent.identity?.name || agent.name || agent.id;
      
      state.currentView = 'agent';
      document.getElementById('mainTitle').textContent = `${emoji} ${name}`;
      document.getElementById('mainSubtitle').textContent = `Agent: ${agent.id}`;
      
      const contentArea = document.getElementById('overviewArea');
      contentArea.innerHTML = `
        <div class="agent-details" style="padding: 24px;">
          <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 24px;">
            <div style="font-size: 3rem;">${emoji}</div>
            <div>
              <h2 style="margin: 0;">${escapeHtml(name)}</h2>
              <div style="color: var(--text-dim);">ID: ${escapeHtml(agent.id)}</div>
              ${agent.isDefault ? '<div style="color: var(--green); font-size: 0.85rem;">Default Agent</div>' : ''}
            </div>
          </div>
          
          <div style="display: grid; gap: 16px; max-width: 600px;">
            <div class="detail-card" style="background: var(--bg-secondary); padding: 16px; border-radius: 8px;">
              <div style="font-weight: 600; margin-bottom: 8px;">Model</div>
              <div style="color: var(--text-dim);">${escapeHtml(agent.model || 'Default')}</div>
            </div>
            
            <div class="detail-card" style="background: var(--bg-secondary); padding: 16px; border-radius: 8px;">
              <div style="font-weight: 600; margin-bottom: 8px;">Workspace</div>
              <div style="color: var(--text-dim);">${escapeHtml(agent.workspace || 'Default')}</div>
            </div>
          </div>
          
          <button onclick="startNewSession('${escapeHtml(agent.id)}')" 
                  style="margin-top: 24px; padding: 12px 24px; background: var(--accent); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1rem;">
            Start New Session
          </button>
        </div>
      `;
      
      document.getElementById('overviewArea').style.display = 'block';
      document.getElementById('chatArea').style.display = 'none';
      updateMobileHeader();
      closeSidebar();
    }
    
    async function startNewSession(agentId) {
      const timestamp = Date.now();
      const sessionKey = `agent:${agentId}:webchat:${timestamp}`;
      const idempotencyKey = `new-${agentId}-${timestamp}`;
      try {
        // Initialize session by sending a greeting
        await rpcCall('chat.send', {
          sessionKey,
          message: 'Hello!',
          idempotencyKey
        });
        // Open the new session
        openSession(sessionKey);
      } catch (err) {
        console.error('Failed to start session:', err);
        alert('Failed to start new session: ' + err.message);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SESSIONS UI
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function renderSessionItem(s, isNested = false) {
      const isActive = state.currentSession && state.currentSession.key === s.key;
      const isSelected = state.selectedSessions.has(s.key);
      const agentStatus = getAgentStatus(s.key);
      const tooltip = getStatusTooltip(agentStatus);
      const isPinned = isSessionPinned(s.key);
      const isArchived = isSessionArchived(s.key);
      const clickHandler = state.multiSelectMode 
        ? `toggleSessionSelection('${escapeHtml(s.key)}')`
        : `openSession('${escapeHtml(s.key)}')`;
      
      const isGenerating = state.generatingTitles.has(s.key);
      const sessionName = getSessionName(s, true);  // This triggers auto-generation
      const hasUnread = !isActive && isSessionUnread(s.key);
      const parsed = parseSessionGroup(s.key);
      
      // For nested items, use full session name (with auto-generated title if available)
      let displayName = sessionName;
      
      return `
        <div class="item ${isActive ? 'active' : ''} ${isArchived ? 'archived-session' : ''} ${hasUnread ? 'unread' : ''} ${isNested ? 'nested-item' : ''}" data-session-key="${escapeHtml(s.key)}" onclick="${clickHandler}">
          <div class="session-checkbox ${isSelected ? 'checked' : ''}" data-key="${escapeHtml(s.key)}" onclick="toggleSessionSelection('${escapeHtml(s.key)}', event)"></div>
          <div class="item-icon">${isNested ? 'ğŸ’¬' : getSessionIcon(s)}${s.compactionCount > 0 ? '<span class="compaction-badge" title="Compacted ' + s.compactionCount + 'x">ğŸ“œ</span>' : ''}</div>
          <div class="item-content">
            <div class="item-name ${isGenerating ? 'title-generating' : ''}">${escapeHtml(displayName)}</div>
            <div class="item-meta">${escapeHtml(getSessionMeta(s))}</div>
            ${renderSessionStatusLine(s.key)}
          </div>
          <div class="session-actions">
            <button class="session-action-btn ${hasUnread ? 'unread' : ''}" 
                    onclick="${hasUnread ? `markSessionRead('${escapeHtml(s.key)}'); event.stopPropagation(); renderSessions();` : `markSessionUnread('${escapeHtml(s.key)}', event)`}" 
                    title="${hasUnread ? 'Mark read' : 'Mark unread'}">
              ${hasUnread ? 'â—' : 'â—‹'}
            </button>
            <button class="session-action-btn ${isPinned ? 'pinned' : ''}" 
                    onclick="event.stopPropagation(); togglePinSession('${escapeHtml(s.key)}')" 
                    title="${isPinned ? 'Unpin' : 'Pin'}">
              ${isPinned ? 'â˜…' : 'â˜†'}
            </button>
            <button class="session-action-btn" 
                    onclick="promptRenameSession('${escapeHtml(s.key)}', event)" 
                    title="Rename">
              âœï¸
            </button>
            <button class="session-action-btn" 
                    onclick="generateSessionTitle('${escapeHtml(s.key)}', event)" 
                    title="Auto-generate title">
              âœ¨
            </button>
            <button class="session-action-btn" 
                    onclick="askSessionForSummary('${escapeHtml(s.key)}', event)" 
                    title="Ask for full summary">
              ğŸ“‹
            </button>
            <button class="session-action-btn ${isArchived ? 'archived' : ''}" 
                    onclick="event.stopPropagation(); toggleArchiveSession('${escapeHtml(s.key)}')" 
                    title="${isArchived ? 'Unarchive' : 'Archive'}">
              ${isArchived ? 'ğŸ“¤' : 'ğŸ“¥'}
            </button>
          </div>
          <div class="agent-status ${agentStatus}" data-tooltip="${tooltip}"></div>
        </div>
      `;
    }
    
    function renderSessions() {
      const container = document.getElementById('sessionsList');
      const archivedToggle = document.getElementById('showArchivedToggle');
      
      // Count archived sessions
      const archivedCount = state.sessions.filter(s => isSessionArchived(s.key)).length;
      
      // Show/hide archived toggle
      if (archivedToggle) {
        archivedToggle.style.display = archivedCount > 0 ? 'flex' : 'none';
        archivedToggle.querySelector('input').checked = state.showArchived;
      }
      
      // Show/hide mark all read button
      const markAllReadBtn = document.getElementById('markAllReadBtn');
      if (markAllReadBtn) {
        const unreadCount = getUnreadCount();
        markAllReadBtn.style.display = unreadCount > 0 ? 'inline-flex' : 'none';
        markAllReadBtn.title = `Mark all read (${unreadCount})`;
      }
      
      // Filter sessions
      let displaySessions = state.sessions.filter(s => {
        if (isSessionArchived(s.key) && !state.showArchived) return false;
        if (!matchesSearch(s)) return false;
        return true;
      });
      
      // Sort: pinned first, then by updatedAt
      displaySessions.sort((a, b) => {
        const aPinned = isSessionPinned(a.key);
        const bPinned = isSessionPinned(b.key);
        if (aPinned && !bPinned) return -1;
        if (!aPinned && bPinned) return 1;
        return (b.updatedAt || 0) - (a.updatedAt || 0);
      });
      
      if (displaySessions.length === 0) {
        container.innerHTML = `<div style="padding: 16px; color: var(--text-dim); font-size: 0.85rem;">${state.showArchived ? 'No sessions' : 'No active sessions'}</div>`;
        return;
      }
      
      // Group sessions by their parent group
      const groups = new Map(); // groupKey -> { sessions: [], latestUpdate: number }
      const standalone = []; // sessions that don't belong to a group
      
      for (const s of displaySessions) {
        const parsed = parseSessionGroup(s.key);
        if (parsed.type === 'topic' && parsed.isGrouped) {
          if (!groups.has(parsed.groupKey)) {
            groups.set(parsed.groupKey, { sessions: [], latestUpdate: 0 });
          }
          const group = groups.get(parsed.groupKey);
          group.sessions.push(s);
          group.latestUpdate = Math.max(group.latestUpdate, s.updatedAt || 0);
        } else {
          standalone.push(s);
        }
      }
      
      // Sort sessions within each group by updatedAt
      for (const group of groups.values()) {
        group.sessions.sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
      }
      
      // Build combined list: groups + standalone, sorted by latest activity
      const combined = [];
      for (const [groupKey, group] of groups) {
        combined.push({ type: 'group', groupKey, ...group });
      }
      for (const s of standalone) {
        combined.push({ type: 'session', session: s, latestUpdate: s.updatedAt || 0 });
      }
      
      // Sort combined by pinned status and latest update
      combined.sort((a, b) => {
        // Check if any session in group is pinned
        const aPinned = a.type === 'group' 
          ? a.sessions.some(s => isSessionPinned(s.key))
          : isSessionPinned(a.session.key);
        const bPinned = b.type === 'group'
          ? b.sessions.some(s => isSessionPinned(s.key))
          : isSessionPinned(b.session.key);
        if (aPinned && !bPinned) return -1;
        if (!aPinned && bPinned) return 1;
        return (b.latestUpdate || 0) - (a.latestUpdate || 0);
      });
      
      // Render
      let html = '';
      for (const item of combined) {
        if (item.type === 'group') {
          const expanded = isGroupExpanded(item.groupKey);
          const groupName = getGroupDisplayName(item.groupKey);
          const unreadCount = item.sessions.filter(s => isSessionUnread(s.key)).length;
          const hasActiveSession = item.sessions.some(s => state.currentSession?.key === s.key);
          
          html += `
            <div class="session-group ${hasActiveSession ? 'has-active' : ''}">
              <div class="session-group-header" onclick="toggleGroupExpanded('${escapeHtml(item.groupKey)}')">
                <span class="group-expand-icon">${expanded ? 'â–¼' : 'â–¶'}</span>
                <span class="group-icon">ğŸ‘¥</span>
                <span class="group-name">${escapeHtml(groupName)}</span>
                <span class="group-count">${item.sessions.length}</span>
                ${unreadCount > 0 ? `<span class="group-unread">${unreadCount}</span>` : ''}
                <button class="session-action-btn" onclick="event.stopPropagation(); generateGroupTitles('${escapeHtml(item.groupKey)}', event)" title="Auto-generate all topic titles">âœ¨</button>
                <button class="session-action-btn" onclick="event.stopPropagation(); promptRenameSession('${escapeHtml(item.groupKey)}', event)" title="Rename group">âœï¸</button>
              </div>
              ${expanded ? `<div class="session-group-items">${item.sessions.map(s => renderSessionItem(s, true)).join('')}</div>` : ''}
            </div>
          `;
        } else {
          html += renderSessionItem(item.session, false);
        }
      }
      
      container.innerHTML = html;
      
      // Update select all checkbox state
      if (state.multiSelectMode) {
        updateCheckboxStates();
      }
    }
    
    function getSessionIcon(s) {
      if (s.key.includes(':subagent:')) return 'âš¡';
      if (s.key.includes(':app:')) return 'ğŸ› ï¸';
      if (s.key.startsWith('cron:')) return 'â°';
      if (s.key.includes(':group:')) return 'ğŸ‘¥';
      return 'ğŸ’¬';
    }
    
    function getSessionName(s, triggerAutoGen = false) {
      // Check for custom name first
      const customName = getCustomSessionName(s.key);
      if (customName) return customName;
      
      // Check if currently generating
      if (state.generatingTitles.has(s.key)) {
        return 'âœ¨ Generating';
      }
      
      // Auto-trigger title generation for sessions with messages
      if (triggerAutoGen && !state.attemptedTitles.has(s.key)) {
        // Only auto-generate for sessions that have messages and aren't special
        const isSpecial = s.key === 'agent:main:main' || 
                         s.key.includes(':subagent:') || 
                         s.key.includes(':app:') ||
                         s.key.startsWith('cron:');
        if (!isSpecial && s.totalTokens > 0) {
          autoGenerateTitle(s.key);
        }
      }
      
      return getDefaultSessionName(s);
    }
    
    function getDefaultSessionName(s) {
      if (!s) return 'Unknown';
      if (s.key === 'agent:main:main') return 'Main';
      if (s.key.includes(':subagent:')) return s.label || 'Sub-agent';
      if (s.key.includes(':app:')) return `App: ${s.key.split(':app:')[1]}`;
      if (s.key.startsWith('cron:')) return s.key.replace('cron:', 'Cron: ');
      // Telegram topics: show "Topic N" or channel info
      if (s.key.includes(':topic:')) {
        const topicMatch = s.key.match(/:topic:(\d+)$/);
        if (topicMatch) return `Topic ${topicMatch[1]}`;
      }
      // Telegram groups without topic
      if (s.key.includes(':telegram:group:')) {
        const groupMatch = s.key.match(/:group:(-?\d+)(?:$|:)/);
        if (groupMatch) return `Group ${groupMatch[1].slice(-4)}`;
      }
      // Telegram DMs
      if (s.key.includes(':telegram:') && !s.key.includes(':group:')) {
        return s.displayName || 'Telegram DM';
      }
      return s.displayName || s.key.split(':').pop();
    }
    
    function getSessionMeta(s) {
      const ago = timeAgo(s.updatedAt);
      const model = s.model ? s.model.split('/').pop().split('-')[0] : '';
      return `${ago}${model ? ' â€¢ ' + model : ''}`;
    }
    
    function isSessionCompacted(s) {
      return s.compactionCount > 0;
    }
    
    function getSessionStatus(s) {
      // Check if actively streaming
      if (state.activeRuns.has(s.key)) return 'running';
      if (s.abortedLastRun) return 'error';
      const mins = (Date.now() - s.updatedAt) / 60000;
      if (mins < 2) return 'active';
      return 'idle';
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // APPS UI
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function renderApps() {
      const container = document.getElementById('appsList');
      
      if (state.apps.length === 0) {
        container.innerHTML = `<div style="padding: 16px; color: var(--text-dim); font-size: 0.85rem;">No apps configured</div>`;
        return;
      }
      
      container.innerHTML = state.apps.map(app => `
        <a href="/app?id=${escapeHtml(app.id)}" target="_blank" class="item">
          <div class="item-icon">${app.icon || 'ğŸ“¦'}</div>
          <div class="item-content">
            <div class="item-name">${escapeHtml(app.name)}</div>
            <div class="item-meta">:${app.port}</div>
          </div>
          <div class="item-status idle" id="app-status-${escapeHtml(app.id)}"></div>
        </a>
      `).join('');
    }
    
    async function checkAppStatus(app) {
      const dot = document.getElementById(`app-status-${app.id}`);
      if (!dot) return;
      
      try {
        const res = await fetch(`/${app.id}/`, { method: 'HEAD' });
        dot.className = 'item-status ' + (res.ok || res.status === 401 ? 'active' : 'error');
      } catch {
        dot.className = 'item-status error';
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MOBILE NAVIGATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      const overlay = document.getElementById('sidebarOverlay');
      sidebar.classList.toggle('open');
      overlay.classList.toggle('active');
      document.body.style.overflow = sidebar.classList.contains('open') ? 'hidden' : '';
    }
    
    function closeSidebar() {
      const sidebar = document.getElementById('sidebar');
      const overlay = document.getElementById('sidebarOverlay');
      sidebar.classList.remove('open');
      overlay.classList.remove('active');
      document.body.style.overflow = '';
    }
    
    function updateMobileHeader() {
      const menuBtn = document.getElementById('menuBtn');
      const backBtn = document.getElementById('backBtn');
      const mobileTitle = document.getElementById('mobileTitle');
      
      if (state.currentView === 'chat' && state.currentSession) {
        menuBtn.style.display = 'none';
        backBtn.style.display = 'flex';
        mobileTitle.textContent = getSessionName(state.currentSession);
      } else if (state.currentView === 'agent') {
        menuBtn.style.display = 'none';
        backBtn.style.display = 'flex';
        mobileTitle.textContent = document.getElementById('mainTitle').textContent;
      } else {
        menuBtn.style.display = 'flex';
        backBtn.style.display = 'none';
        mobileTitle.textContent = 'Sharp';
      }
    }
    
    function goBack() {
      showOverview();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VIEWS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function showOverview() {
      state.currentView = 'overview';
      state.currentSession = null;
      localStorage.removeItem('sharp_current_session');
      
      document.getElementById('overviewView').classList.add('active');
      document.getElementById('chatView').classList.remove('active');
      document.getElementById('mainTitle').textContent = 'Dashboard';
      document.getElementById('mainSubtitle').textContent = '';
      document.getElementById('headerAction').style.display = 'none';
      document.getElementById('headerStatusIndicator').style.display = 'none';
      
      renderSessions();
      updateMobileHeader();
      closeSidebar();
    }
    
    async function openSession(key) {
      const session = state.sessions.find(s => s.key === key);
      if (!session) return;
      
      // Save to localStorage for restore on refresh
      localStorage.setItem('sharp_current_session', key);
      
      // Mark session as read
      markSessionRead(key);
      
      // Clear tool activity from previous session
      clearAllTools();
      
      state.currentView = 'chat';
      state.currentSession = session;
      state.chatHistory = [];
      state.isThinking = state.activeRuns.has(key);
      
      // Initialize session status if not set
      if (!state.sessionStatus[key]) {
        state.sessionStatus[key] = state.connected ? 'idle' : 'offline';
      }
      
      document.getElementById('overviewView').classList.remove('active');
      document.getElementById('chatView').classList.add('active');
      document.getElementById('mainTitle').textContent = getSessionName(session);
      document.getElementById('mainSubtitle').textContent = session.key;
      
      // Show header status indicator
      document.getElementById('headerStatusIndicator').style.display = 'block';
      updateHeaderStatus();
      
      document.getElementById('sessionKeyDisplay').textContent = session.key;
      document.getElementById('sessionModel').textContent = session.model?.split('/').pop() || 'unknown';
      document.getElementById('sessionTokens').textContent = session.totalTokens?.toLocaleString() || '0';
      
      const actionBtn = document.getElementById('headerAction');
      if (session.key === 'agent:main:main') {
        actionBtn.textContent = '+ New Session';
        actionBtn.style.display = 'block';
      } else {
        actionBtn.style.display = 'none';
      }
      
      renderSessions();
      updateSendButton();
      updateMobileHeader();
      closeSidebar();
      
      await loadSessionHistory(key);
      
      document.getElementById('chatInput').focus();
    }
    
    async function loadSessionHistory(key) {
      const container = document.getElementById('chatMessages');
      container.innerHTML = '<div class="message system">Loading history...</div>';
      
      try {
        const result = await rpcCall('chat.history', { sessionKey: key, limit: 50 });
        const messages = result?.messages || [];
        
        if (messages.length > 0) {
          renderChatHistory(messages);
        } else {
          container.innerHTML = '<div class="message system">No messages yet</div>';
        }
      } catch (err) {
        container.innerHTML = `<div class="message system">Error loading history: ${escapeHtml(err.message)}</div>`;
      }
    }
    
    function renderChatHistory(messages) {
      const container = document.getElementById('chatMessages');
      
      if (!messages || messages.length === 0) {
        container.innerHTML = '<div class="message system">No messages yet. Start the conversation!</div>';
        return;
      }
      
      container.innerHTML = messages.map(m => {
        if (m.role === 'user') {
          const text = extractText(m.content);
          if (!text) return '';
          const timeHtml = m.timestamp ? `<div class="message-time">${formatMessageTime(new Date(m.timestamp))}</div>` : '';
          return `<div class="message user"><div class="message-content">${escapeHtml(text)}</div>${timeHtml}</div>`;
        } else if (m.role === 'assistant') {
          const text = extractText(m.content);
          if (!text) return '';
          const timeHtml = m.timestamp ? `<div class="message-time">${formatMessageTime(new Date(m.timestamp))}</div>` : '';
          return `<div class="message assistant"><div class="message-content">${formatMessage(text)}</div>${timeHtml}</div>`;
        }
        return '';
      }).filter(Boolean).join('');
      
      scrollChatToBottom();
    }
    
    function extractText(content) {
      if (typeof content === 'string') return content;
      if (!Array.isArray(content)) return '';
      
      const textBlocks = content.filter(b => b.type === 'text');
      if (textBlocks.length > 0) {
        return textBlocks.map(b => b.text).join('\n');
      }
      
      if (content[0]?.text) return content[0].text;
      
      return '';
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CHAT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async function sendMessage() {
      const input = document.getElementById('chatInput');
      const text = input.value.trim();
      
      if (!text || !state.currentSession) return;
      
      const sessionKey = state.currentSession.key;
      
      // If agent is busy, queue the message
      if (state.isThinking) {
        state.messageQueue.push({ text, sessionKey });
        updateQueueIndicator();
        input.value = '';
        input.style.height = 'auto';
        addChatMessage('user queued', text);
        return;
      }
      
      input.value = '';
      input.style.height = 'auto';
      
      addChatMessage('user', text);
      await processMessage(text, sessionKey);
    }
    
    async function processMessage(text, sessionKey) {
      state.isThinking = true;
      setSessionStatus(sessionKey, 'thinking');
      updateSendButton();
      
      try {
        const idempotencyKey = `msg-${sessionKey}-${Date.now()}`;
        const result = await rpcCall('chat.send', {
          sessionKey: sessionKey,
          message: text,
          idempotencyKey
        }, 130000);
        
        if (result?.reply) {
          addChatMessage('assistant', result.reply);
        }
        
        setSessionStatus(sessionKey, 'idle');
        refresh();
        
      } catch (err) {
        addChatMessage('system', `Error: ${err.message}`);
        setSessionStatus(sessionKey, 'error');
      } finally {
        state.isThinking = false;
        updateSendButton();
        processNextInQueue();
      }
    }
    
    function processNextInQueue() {
      if (state.messageQueue.length === 0) return;
      
      const next = state.messageQueue.shift();
      updateQueueIndicator();
      
      // Convert queued message to regular
      const queuedMsgs = document.querySelectorAll('.message.user.queued');
      if (queuedMsgs.length > 0) {
        queuedMsgs[0].classList.remove('queued');
      }
      
      processMessage(next.text, next.sessionKey);
    }
    
    function updateQueueIndicator() {
      const indicator = document.getElementById('queueIndicator');
      const countEl = document.getElementById('queueCount');
      if (!indicator || !countEl) return;
      
      const count = state.messageQueue.length;
      countEl.textContent = count;
      indicator.classList.toggle('visible', count > 0);
    }
    
    function clearMessageQueue() {
      // Remove queued messages from UI
      document.querySelectorAll('.message.user.queued').forEach(el => el.remove());
      state.messageQueue = [];
      updateQueueIndicator();
    }
    
    function addChatMessage(role, content, timestamp = null) {
      const container = document.getElementById('chatMessages');
      const msg = document.createElement('div');
      msg.className = `message ${role}`;
      
      // Format content
      let contentHtml;
      if (role === 'assistant' && !role.includes('thinking')) {
        contentHtml = formatMessage(content);
      } else {
        contentHtml = escapeHtml(content);
      }
      
      // Add timestamp
      const time = timestamp ? new Date(timestamp) : new Date();
      const timeStr = formatMessageTime(time);
      
      msg.innerHTML = `<div class="message-content">${contentHtml}</div><div class="message-time">${timeStr}</div>`;
      
      container.appendChild(msg);
      scrollChatToBottom();
      return msg;
    }
    
    function formatMessageTime(date) {
      const now = new Date();
      const isToday = date.toDateString() === now.toDateString();
      const yesterday = new Date(now);
      yesterday.setDate(yesterday.getDate() - 1);
      const isYesterday = date.toDateString() === yesterday.toDateString();
      
      const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      
      if (isToday) {
        return timeStr;
      } else if (isYesterday) {
        return `Yesterday ${timeStr}`;
      } else {
        return date.toLocaleDateString([], { month: 'short', day: 'numeric' }) + ' ' + timeStr;
      }
    }
    
    function scrollChatToBottom() {
      const container = document.getElementById('chatMessages');
      if (container) {
        // Use requestAnimationFrame for reliable scrolling after DOM update
        requestAnimationFrame(() => {
          container.scrollTop = container.scrollHeight;
        });
      }
    }
    
    function formatMessage(text) {
      return escapeHtml(text)
        .replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
        .replace(/`([^`]+)`/g, '<code>$1</code>')
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        .replace(/\n/g, '<br>');
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      // Also escape single quotes for use in single-quoted attributes (onclick handlers)
      return div.innerHTML.replace(/'/g, '&#39;');
    }
    
    function handleChatKey(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
      if (e.key === 'Escape' && state.isThinking) {
        e.preventDefault();
        stopAgent();
      }
    }
    
    function autoResize(el) {
      el.style.height = 'auto';
      el.style.height = Math.min(el.scrollHeight, 200) + 'px';
    }
    
    function updateSendButton() {
      document.getElementById('sendBtn').disabled = state.isThinking;
      const stopBtn = document.getElementById('stopBtn');
      if (stopBtn) stopBtn.disabled = !state.isThinking;
    }
    
    async function stopAgent() {
      if (!state.isThinking || !state.currentSession) return;
      
      try {
        const idempotencyKey = `stop-${state.currentSession.key}-${Date.now()}`;
        await rpcCall('chat.send', {
          sessionKey: state.currentSession.key,
          message: '/stop',
          idempotencyKey
        }, 10000);
        addChatMessage('system', 'â¹ Stop requested');
      } catch (err) {
        addChatMessage('system', `Failed to stop: ${err.message}`);
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EXPORT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async function exportChatAsMarkdown() {
      if (!state.currentSession) return;
      
      try {
        // Fetch fresh history
        const result = await rpcCall('chat.history', { 
          sessionKey: state.currentSession.key, 
          limit: 500 
        });
        const messages = result?.messages || [];
        
        if (messages.length === 0) {
          alert('No messages to export');
          return;
        }
        
        // Build markdown
        const sessionName = getSessionName(state.currentSession);
        const timestamp = new Date().toISOString();
        const dateStr = new Date().toISOString().split('T')[0];
        
        let md = `# Chat Export: ${sessionName}\n`;
        md += `Exported: ${timestamp}\n\n`;
        md += `---\n\n`;
        
        for (const msg of messages) {
          const role = msg.role === 'user' ? 'User' : 'Assistant';
          md += `## ${role}\n\n`;
          
          // Handle content
          if (typeof msg.content === 'string') {
            md += msg.content + '\n\n';
          } else if (Array.isArray(msg.content)) {
            for (const block of msg.content) {
              if (block.type === 'text') {
                md += block.text + '\n\n';
              } else if (block.type === 'tool_use') {
                md += `\`\`\`tool_call: ${block.name}\n`;
                md += JSON.stringify(block.input, null, 2) + '\n';
                md += `\`\`\`\n\n`;
              } else if (block.type === 'tool_result') {
                const content = typeof block.content === 'string' 
                  ? block.content 
                  : JSON.stringify(block.content, null, 2);
                const preview = content.length > 500 
                  ? content.slice(0, 500) + '...' 
                  : content;
                md += `\`\`\`tool_result\n${preview}\n\`\`\`\n\n`;
              } else if (block.type === 'image') {
                md += `[Image: ${block.source?.media_type || 'image'}]\n\n`;
              }
            }
          }
          
          md += `---\n\n`;
        }
        
        // Sanitize session key for filename
        const safeKey = state.currentSession.key
          .replace(/[^a-zA-Z0-9-_]/g, '-')
          .replace(/-+/g, '-')
          .slice(0, 50);
        const filename = `chat-${safeKey}-${dateStr}.md`;
        
        // Trigger download
        const blob = new Blob([md], { type: 'text/markdown;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
      } catch (err) {
        console.error('Export failed:', err);
        alert('Export failed: ' + err.message);
      }
    }
    
    function headerAction() {
      if (state.currentSession?.key === 'agent:main:main') {
        if (confirm('Start a new session? This will reset the conversation.')) {
          sendMessage('/new');
        }
      }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MULTI-SELECT MODE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function enterMultiSelect() {
      state.multiSelectMode = true;
      state.selectedSessions.clear();
      document.getElementById('sessionsList').classList.add('multi-select-mode');
      document.getElementById('selectModeBtn').style.display = 'none';
      updateBulkActionBar();
      renderSessions();
    }
    
    function exitMultiSelect() {
      state.multiSelectMode = false;
      state.selectedSessions.clear();
      document.getElementById('sessionsList').classList.remove('multi-select-mode');
      document.getElementById('selectModeBtn').style.display = '';
      document.getElementById('bulkActionBar').classList.remove('visible');
      renderSessions();
    }
    
    function toggleSessionSelection(key, event) {
      if (event) {
        event.stopPropagation();
      }
      
      if (state.selectedSessions.has(key)) {
        state.selectedSessions.delete(key);
      } else {
        state.selectedSessions.add(key);
      }
      
      updateBulkActionBar();
      updateCheckboxStates();
    }
    
    function toggleSelectAll() {
      const mainSessions = state.sessions.filter(s => !s.key.includes(':subagent:'));
      
      if (state.selectedSessions.size === mainSessions.length) {
        // Deselect all
        state.selectedSessions.clear();
      } else {
        // Select all
        mainSessions.forEach(s => state.selectedSessions.add(s.key));
      }
      
      updateBulkActionBar();
      updateCheckboxStates();
    }
    
    function updateBulkActionBar() {
      const bar = document.getElementById('bulkActionBar');
      const count = state.selectedSessions.size;
      
      if (count > 0) {
        bar.classList.add('visible');
        document.getElementById('bulkCount').textContent = `${count} selected`;
      } else {
        bar.classList.remove('visible');
      }
    }
    
    function updateCheckboxStates() {
      // Update individual checkboxes
      document.querySelectorAll('.session-checkbox[data-key]').forEach(checkbox => {
        const key = checkbox.dataset.key;
        if (state.selectedSessions.has(key)) {
          checkbox.classList.add('checked');
        } else {
          checkbox.classList.remove('checked');
        }
      });
      
      // Update select all checkbox
      const mainSessions = state.sessions.filter(s => !s.key.includes(':subagent:'));
      const selectAllCheckbox = document.getElementById('selectAllCheckbox');
      if (selectAllCheckbox) {
        if (mainSessions.length > 0 && state.selectedSessions.size === mainSessions.length) {
          selectAllCheckbox.classList.add('checked');
        } else {
          selectAllCheckbox.classList.remove('checked');
        }
      }
    }
    
    async function bulkArchive() {
      if (state.selectedSessions.size === 0) return;
      
      const count = state.selectedSessions.size;
      if (!confirm(`Archive ${count} session${count > 1 ? 's' : ''}?`)) return;
      
      const keys = [...state.selectedSessions];
      let archived = 0;
      
      for (const key of keys) {
        try {
          await rpcCall('sessions.archive', { sessionKey: key });
          archived++;
        } catch (err) {
          console.error(`Failed to archive ${key}:`, err);
        }
      }
      
      exitMultiSelect();
      await refresh();
      
      console.log(`[Sharp] Archived ${archived}/${count} sessions`);
    }
    
    async function bulkPin() {
      if (state.selectedSessions.size === 0) return;
      
      const keys = [...state.selectedSessions];
      let pinned = 0;
      
      for (const key of keys) {
        try {
          await rpcCall('sessions.pin', { sessionKey: key, pinned: true });
          pinned++;
        } catch (err) {
          console.error(`Failed to pin ${key}:`, err);
        }
      }
      
      exitMultiSelect();
      await refresh();
      
      console.log(`[Sharp] Pinned ${pinned}/${keys.length} sessions`);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // OVERVIEW
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function updateOverview() {
      renderSessionsGrid();
      renderAppsGrid();
      renderSubagentsGrid();
    }
    
    function renderSessionsGrid() {
      const mainSessions = state.sessions.filter(s => !s.key.includes(':subagent:'));
      const container = document.getElementById('sessionsGrid');
      document.getElementById('sessionCount').textContent = mainSessions.length;
      
      if (mainSessions.length === 0) {
        container.innerHTML = `
          <div class="session-card" style="border-style: dashed; opacity: 0.6;">
            <div class="card-top">
              <div class="card-icon">ğŸ’¬</div>
              <div class="card-info">
                <div class="card-name">No active sessions</div>
                <div class="card-desc">Start a conversation to see it here</div>
              </div>
            </div>
          </div>
        `;
        return;
      }
      
      container.innerHTML = mainSessions.map(s => {
        const preview = getMessagePreview(s);
        const agentStatus = getAgentStatus(s.key);
        const tooltip = getStatusTooltip(agentStatus);
        return `
          <div class="session-card" onclick="openSession('${escapeHtml(s.key)}')">
            <div class="card-top">
              <div class="card-icon">${getSessionIcon(s)}</div>
              <div class="card-info">
                <div class="card-name">${escapeHtml(getSessionName(s))}</div>
                <div class="card-desc">${escapeHtml(s.model?.split('/').pop() || 'unknown model')}</div>
              </div>
              <div class="agent-status ${agentStatus}" data-tooltip="${tooltip}" style="width: 10px; height: 10px;"></div>
            </div>
            ${preview ? `<div class="card-preview">${escapeHtml(preview)}</div>` : ''}
            <div class="card-footer">
              <span>${timeAgo(s.updatedAt)}</span>
              <span class="card-badge">${(s.totalTokens || 0).toLocaleString()} tokens</span>
            </div>
          </div>
        `;
      }).join('');
    }
    
    function renderAppsGrid() {
      const container = document.getElementById('appsGrid');
      document.getElementById('appCount').textContent = state.apps.length;
      
      if (state.apps.length === 0) {
        container.innerHTML = `
          <div class="app-card" style="border-style: dashed; opacity: 0.6;">
            <div class="card-top">
              <div class="card-icon">ğŸ“¦</div>
              <div class="card-info">
                <div class="card-name">No apps configured</div>
                <div class="card-desc">Add apps to apps.json</div>
              </div>
            </div>
          </div>
        `;
        return;
      }
      
      container.innerHTML = state.apps.map(app => `
        <a href="/app?id=${escapeHtml(app.id)}" target="_blank" class="app-card" style="text-decoration: none; color: inherit;">
          <div class="card-top">
            <div class="card-icon">${app.icon || 'ğŸ“¦'}</div>
            <div class="card-info">
              <div class="card-name">${escapeHtml(app.name)}</div>
              <div class="card-desc">${escapeHtml(app.description || '')}</div>
            </div>
            <div class="card-status-dot idle" id="app-grid-status-${escapeHtml(app.id)}"></div>
          </div>
          <div class="card-footer">
            <span>Port ${app.port}</span>
            <span class="card-badge">${escapeHtml(app.id)}</span>
          </div>
        </a>
      `).join('');
      
      state.apps.forEach(app => {
        checkAppGridStatus(app);
      });
    }
    
    async function checkAppGridStatus(app) {
      const dot = document.getElementById(`app-grid-status-${app.id}`);
      if (!dot) return;
      
      try {
        const res = await fetch(`/${app.id}/`, { method: 'HEAD' });
        dot.className = 'card-status-dot ' + (res.ok || res.status === 401 ? 'active' : 'error');
      } catch {
        dot.className = 'card-status-dot error';
      }
    }
    
    function renderSubagentsGrid() {
      const subagents = state.sessions.filter(s => s.key.includes(':subagent:'));
      const section = document.getElementById('subagentsSection');
      const container = document.getElementById('subagentsGrid');
      document.getElementById('taskCount').textContent = subagents.length;
      
      if (subagents.length === 0) {
        section.style.display = 'none';
        return;
      }
      
      section.style.display = 'block';
      
      container.innerHTML = subagents.map(s => {
        const preview = getMessagePreview(s);
        const agentStatus = getAgentStatus(s.key);
        const tooltip = getStatusTooltip(agentStatus);
        return `
          <div class="session-card" onclick="openSession('${escapeHtml(s.key)}')">
            <div class="card-top">
              <div class="card-icon">âš¡</div>
              <div class="card-info">
                <div class="card-name">${escapeHtml(s.label || 'Sub-agent')}</div>
                <div class="card-desc">${escapeHtml(s.model?.split('/').pop() || 'unknown')}</div>
              </div>
              <div class="agent-status ${agentStatus}" data-tooltip="${tooltip}" style="width: 10px; height: 10px;"></div>
            </div>
            ${preview ? `<div class="card-preview">${escapeHtml(preview)}</div>` : ''}
            <div class="card-footer">
              <span>${timeAgo(s.updatedAt)}</span>
            </div>
          </div>
        `;
      }).join('');
    }
    
    function getMessagePreview(s) {
      if (s.messages?.[0]) {
        const msg = s.messages[0];
        const text = extractText(msg.content);
        if (text) return text.slice(0, 100) + (text.length > 100 ? '...' : '');
      }
      return '';
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UTILITIES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function timeAgo(ts) {
      const diff = Date.now() - ts;
      const mins = Math.floor(diff / 60000);
      const hours = Math.floor(diff / 3600000);
      const days = Math.floor(diff / 86400000);
      
      if (mins < 1) return 'just now';
      if (mins < 60) return `${mins}m ago`;
      if (hours < 24) return `${hours}h ago`;
      return `${days}d ago`;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // KEYBOARD SHORTCUTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (state.multiSelectMode) {
          exitMultiSelect();
        } else if (state.currentView === 'chat') {
          showOverview();
        }
      }
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INIT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function init() {
      // Restore active runs from localStorage (before connecting)
      restoreActiveRuns();
      
      // Initialize auto-archive dropdown UI
      initAutoArchiveUI();
      
      connectWebSocket();
      
      // Auto-refresh sessions every 30s
      setInterval(() => {
        if (state.connected) {
          refresh();
        }
      }, 30000);
    }
    
    init();
  </script>
</body>
</html>
